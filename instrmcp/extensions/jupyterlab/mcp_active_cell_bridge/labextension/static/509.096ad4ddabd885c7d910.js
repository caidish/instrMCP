"use strict";(self.webpackChunkmcp_active_cell_bridge=self.webpackChunkmcp_active_cell_bridge||[]).push([[509],{509:(e,t,o)=>{o.r(t),o.d(t,{default:()=>r});var s=o(722),n=o(794),l=o(256),c=o(188);const r={id:"mcp-active-cell-bridge:plugin",description:"Bridge active cell content to MCP server and handle consent dialogs",autoStart:!0,requires:[s.INotebookTracker],activate:(e,t)=>{console.log("MCP Active Cell Bridge extension activated");const o=new WeakMap,r=new WeakMap,d=new WeakMap,a=new WeakMap,i=new WeakMap,u=new WeakMap,p=(e,t)=>t&&!t.isDisposed&&!0===r.get(e),g=e=>{const t=document.createElement("div");return t.textContent=e,t.innerHTML},v=e=>{e&&e.status&&"dead"!==e.status&&(e.registerCommTarget("mcp:server_status",(t,s)=>{var n;const l=((null===(n=null==s?void 0:s.content)||void 0===n?void 0:n.data)||{}).status;if(console.log(`MCP Server Status: Received status update - ${l}`),"server_ready"===l){i.set(e,!0),console.log("MCP Active Cell Bridge: Server is ready, initializing comm connection");const t=u.get(e)||[];u.set(e,[]);for(const e of t)e();m(e).then(()=>{y(e)})}else if("server_stopped"===l){i.set(e,!1),console.log("MCP Active Cell Bridge: Server stopped");const t=o.get(e);t&&!t.isDisposed&&t.close(),o.delete(e),r.delete(e),d.delete(e)}else"server_not_started"===l&&(i.set(e,!1),console.log("MCP Active Cell Bridge: Waiting for server to start"))}),console.log("MCP Server Status: Registered comm target mcp:server_status"))},_=e=>{e&&e.status&&"dead"!==e.status&&(e.registerCommTarget("mcp:capcall",(t,o)=>{console.log("MCP Consent: Backend opened consent comm channel");let s=a.get(e);s||(s=new Set,a.set(e,s)),s.add(t),t.onMsg=e=>{var o;const s=(null===(o=null==e?void 0:e.content)||void 0===o?void 0:o.data)||{},r=s.type;"consent_request"===r?"apply_patch"===(s.operation||"unknown")?(async(e,t,o)=>{o.operation;const s=o.tool_name||"notebook_apply_patch",r=(o.author,o.details||{});console.log(`MCP Consent: Received patch consent request for tool '${s}'`);try{const e=document.createElement("div");e.style.maxWidth="700px";const o=document.createElement("div");o.style.marginBottom="15px",o.innerHTML=`\n          <div style="margin-bottom: 10px;">\n            <strong>Cell Type:</strong> ${r.cell_type||"code"}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Cell Index:</strong> ${r.cell_index||"unknown"}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Description:</strong> ${r.description||"Apply text patch to current cell"}\n          </div>\n        `,e.appendChild(o);const s=document.createElement("div");s.style.marginBottom="15px",s.style.padding="10px",s.style.background="#f5f5f5",s.style.borderRadius="4px";const d=(r.old_text||"").length,a=(r.new_text||"").length,i=a-d,u=i>=0?"+":"";s.innerHTML=`\n          <div style="display: flex; gap: 20px; font-size: 13px;">\n            <div><strong>Remove:</strong> <span style="color: #d32f2f;">${d} chars</span></div>\n            <div><strong>Add:</strong> <span style="color: #388e3c;">${a} chars</span></div>\n            <div><strong>Delta:</strong> <span style="color: ${i>=0?"#388e3c":"#d32f2f"};">${u}${i} chars</span></div>\n          </div>\n        `,e.appendChild(s);const p=document.createElement("div");p.style.marginTop="15px";const v=document.createElement("div");v.innerHTML="<strong>Changes Preview:</strong>",v.style.marginBottom="8px",p.appendChild(v);const{html:_,found:m}=((e,t,o)=>{if(-1===e.indexOf(t))return{html:'<div style="color: #d32f2f; padding: 10px; background: #ffebee; border-radius: 4px;">\n            <strong>⚠️ Warning:</strong> Pattern not found in current cell content.\n          </div>',found:!1};const s=e.replace(t,o),n=(0,c.diffLines)(e,s);let l='<div style="font-family: monospace; font-size: 12px; line-height: 1.4;">',r=1;for(const e of n){const t=e.value.split("\n");""===t[t.length-1]&&t.pop();for(let o=0;o<t.length;o++){const s=t[o];e.added?l+=`<div style="background: #e8f5e9; padding: 2px 8px; border-left: 3px solid #66bb6a;">\n              <span style="color: #999; margin-right: 8px;">+</span><span style="background: #a5d6a7;">${g(s)}</span>\n            </div>`:e.removed?l+=`<div style="background: #ffebee; padding: 2px 8px; border-left: 3px solid #ef5350;">\n              <span style="color: #999; margin-right: 8px;">-</span><span style="background: #ef9a9a; text-decoration: line-through;">${g(s)}</span>\n            </div>`:(l+=`<div style="color: #666; background: #f8f9fa; padding: 2px 8px; border-left: 3px solid #e0e0e0;">\n              <span style="color: #999; margin-right: 8px;">${r}</span>${g(s)}\n            </div>`,r++)}}return l+="</div>",{html:l,found:!0}})(r.cell_content||"",r.old_text||"",r.new_text||""),y=document.createElement("div");if(y.style.maxHeight="400px",y.style.overflow="auto",y.style.border="1px solid #ddd",y.style.borderRadius="4px",y.style.background="white",y.innerHTML=_,p.appendChild(y),e.appendChild(p),!m){const t=document.createElement("div");t.style.marginTop="10px",t.style.padding="10px",t.style.background="#fff3cd",t.style.border="1px solid #ffc107",t.style.borderRadius="4px",t.style.color="#856404",t.innerHTML="\n            <strong>⚠️ Warning:</strong> The pattern to be replaced was not found in the current cell content.\n            The patch will have no effect if you proceed.\n          ",e.appendChild(t)}const h=new l.Widget({node:e}),C=await(0,n.showDialog)({title:"Apply Patch Consent",body:h,buttons:[n.Dialog.cancelButton({label:"Decline"}),n.Dialog.okButton({label:"Allow"}),n.Dialog.warnButton({label:"Always Allow"})],defaultButton:1});let f=!1,b=!1,x="";"Allow"===C.button.label?(f=!0,b=!1,x="User approved patch"):"Always Allow"===C.button.label?(f=!0,b=!0,x="User approved patch with always allow"):(f=!1,b=!1,x="User declined patch"),t.send({type:"consent_response",approved:f,always_allow:b,reason:x}),console.log(`MCP Consent: Sent patch response - approved: ${f}`)}catch(e){console.error("MCP Consent: Failed to show patch consent dialog:",e),t.send({type:"consent_response",approved:!1,always_allow:!1,reason:`Dialog error: ${e}`})}})(0,t,s):(async(e,t,o)=>{const s=o.operation||"unknown",c=o.tool_name||"Unnamed Tool",r=o.author||"Unknown Author",d=o.details||{};console.log(`MCP Consent: Received consent request for ${s} of tool '${c}' by '${r}'`);try{const e=document.createElement("div");e.style.maxWidth="600px";const o=document.createElement("div");if(o.style.marginBottom="15px",o.innerHTML=`\n          <div style="margin-bottom: 10px;">\n            <strong>Operation:</strong> ${s}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Tool:</strong> ${c}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Author:</strong> ${r}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Version:</strong> ${d.version||"N/A"}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Description:</strong> ${d.description||"No description provided"}\n          </div>\n        `,d.capabilities&&d.capabilities.length>0){const e=document.createElement("div");e.style.marginBottom="10px",e.innerHTML=`\n            <div style="margin-bottom: 5px;"><strong>Capabilities:</strong></div>\n            <ul style="margin: 0; padding-left: 20px;">\n              ${d.capabilities.map(e=>`<li>${e}</li>`).join("")}\n            </ul>\n          `,o.appendChild(e)}if(e.appendChild(o),d.source_code){const t=document.createElement("div");t.style.marginTop="15px";const o=document.createElement("div");o.innerHTML="<strong>Source Code:</strong>",o.style.marginBottom="5px",t.appendChild(o);const s=document.createElement("pre");s.style.maxHeight="300px",s.style.overflow="auto",s.style.padding="10px",s.style.backgroundColor="#f5f5f5",s.style.border="1px solid #ddd",s.style.borderRadius="4px",s.style.fontSize="12px",s.style.fontFamily="monospace",s.textContent=d.source_code,t.appendChild(s),e.appendChild(t)}const a=new l.Widget({node:e}),i=await(0,n.showDialog)({title:`Tool ${s.charAt(0).toUpperCase()+s.slice(1)} Consent`,body:a,buttons:[n.Dialog.cancelButton({label:"Decline"}),n.Dialog.okButton({label:"Allow"}),n.Dialog.warnButton({label:"Always Allow"})],defaultButton:1});let u=!1,p=!1,g="";"Allow"===i.button.label?(u=!0,p=!1,g="User approved"):"Always Allow"===i.button.label?(u=!0,p=!0,g="User approved with always allow"):(u=!1,p=!1,g="User declined"),t.send({type:"consent_response",approved:u,always_allow:p,reason:g}),console.log(`MCP Consent: Sent response - approved: ${u}, always_allow: ${p}`)}catch(e){console.error("MCP Consent: Failed to show consent dialog:",e),t.send({type:"consent_response",approved:!1,always_allow:!1,reason:`Dialog error: ${e}`})}})(0,t,s):console.warn(`MCP Consent: Unknown message type: ${r}`)},t.onClose=o=>{console.log("MCP Consent: Comm closed by backend");const s=a.get(e);s&&s.delete(t)}}),console.log("MCP Consent: Registered comm target mcp:capcall"))},m=async e=>{if(!e||!e.status||"dead"===e.status)return console.warn("MCP Active Cell Bridge: Kernel not available or dead"),null;if("idle"!==e.status&&"busy"!==e.status)return console.warn(`MCP Active Cell Bridge: Kernel not ready (status: ${e.status})`),null;let n=o.get(e);if(!n||!p(e,n)){let l=d.get(e);if(l)try{return await l,o.get(e)||null}catch(e){return null}return l=(async()=>{try{return n=e.createComm("mcp:active_cell"),n.onMsg=o=>{var l;const c=(null===(l=null==o?void 0:o.content)||void 0===l?void 0:l.data)||{},r=c.type;"request_current"===r?y(e):"update_cell"===r?(async(e,o,s)=>{const n=s.request_id,l=s.content;try{const e=t.currentWidget,s=t.activeCell;if(!e||!s)return void o.send({type:"update_response",request_id:n,success:!1,message:"No active cell available for update"});s.model.sharedModel.setSource(l),o.send({type:"update_response",request_id:n,success:!0,cell_id:s.model.id,message:"Cell updated successfully"}),console.log(`MCP Active Cell Bridge: Updated cell content (${l.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to update cell:",e),o.send({type:"update_response",request_id:n,success:!1,message:`Failed to update cell: ${e}`})}})(0,n,c):"execute_cell"===r?(async(e,o,n)=>{const l=n.request_id;try{const e=t.currentWidget,n=t.activeCell;if(!e||!n)return void o.send({type:"execute_response",request_id:l,success:!1,message:"No active cell available for execution"});await s.NotebookActions.run(e.content,e.sessionContext),o.send({type:"execute_response",request_id:l,success:!0,cell_id:n.model.id,message:"Cell executed successfully"}),console.log("MCP Active Cell Bridge: Executed active cell")}catch(e){console.error("MCP Active Cell Bridge: Failed to execute cell:",e),o.send({type:"execute_response",request_id:l,success:!1,message:`Failed to execute cell: ${e}`})}})(0,n,c):"add_cell"===r?(async(e,o,n)=>{const l=n.request_id,c=n.cell_type||"code",r=n.position||"below",d=n.content||"";try{const e=t.currentWidget;if(!e)return void o.send({type:"add_cell_response",request_id:l,success:!1,message:"No active notebook available"});const n=["code","markdown","raw"];if(!n.includes(c))return void o.send({type:"add_cell_response",request_id:l,success:!1,message:`Invalid cell_type '${c}'. Must be one of: ${n.join(", ")}`});const a=["above","below"];if(!a.includes(r))return void o.send({type:"add_cell_response",request_id:l,success:!1,message:`Invalid position '${r}'. Must be one of: ${a.join(", ")}`});"above"===r?await s.NotebookActions.insertAbove(e.content):await s.NotebookActions.insertBelow(e.content);const i=t.activeCell;i&&(i.model.type!==c&&await s.NotebookActions.changeCellType(e.content,c),d&&i.model.sharedModel.setSource(d)),o.send({type:"add_cell_response",request_id:l,success:!0,cell_type:c,position:r,content_length:d.length,cell_id:null==i?void 0:i.model.id,message:"Cell added successfully"}),console.log(`MCP Active Cell Bridge: Added ${c} cell ${r} with ${d.length} chars`)}catch(e){console.error("MCP Active Cell Bridge: Failed to add cell:",e),o.send({type:"add_cell_response",request_id:l,success:!1,message:`Failed to add cell: ${e}`})}})(0,n,c):"delete_cell"===r?(async(e,o,n)=>{var l;const c=n.request_id;try{const e=t.currentWidget,n=t.activeCell;if(!e||!n)return void o.send({type:"delete_cell_response",request_id:c,success:!1,message:"No active cell available for deletion"});const r=n.model.id;((null===(l=e.content.model)||void 0===l?void 0:l.cells.length)||0)<=1?(n.model.sharedModel.setSource(""),o.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:r,action:"cleared",message:"Last cell content cleared (cell preserved)"}),console.log("MCP Active Cell Bridge: Cleared last cell content")):(await s.NotebookActions.deleteCells(e.content),o.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:r,action:"deleted",message:"Cell deleted successfully"}),console.log("MCP Active Cell Bridge: Deleted cell"))}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cell:",e),o.send({type:"delete_cell_response",request_id:c,success:!1,message:`Failed to delete cell: ${e}`})}})(0,n,c):"delete_cells_by_number"===r?(async(e,o,s)=>{var n,l;const c=s.request_id,r=s.cell_numbers||[];try{const e=t.currentWidget;if(!e)return void o.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"No active notebook available"});if(!Array.isArray(r)||0===r.length)return void o.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"cell_numbers must be a non-empty array"});const s=e.content,d=null===(n=s.model)||void 0===n?void 0:n.cells;if(!d)return void o.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"Cannot access notebook cells"});const a=new Map;for(let e=0;e<d.length;e++){const t=d.get(e).executionCount;null!=t&&a.set(t,e)}const i=[],u=[];for(const e of r)if(a.has(e)){const t=a.get(e);u.push(t),i.push({cell_number:e,index:t,success:!0})}else i.push({cell_number:e,success:!1,message:`Cell with execution count ${e} not found`});u.sort((e,t)=>t-e);let p=0,g=0;for(const e of u)try{if(1===d.length){const t=d.get(e);if(t){t.sharedModel.setSource("");const o=i.findIndex(t=>t.index===e);-1!==o&&(i[o].message="Last cell - content cleared instead of deleted",i[o].cleared=!0),g++}}else null===(l=s.model)||void 0===l||l.sharedModel.deleteCell(e),p++}catch(t){const o=i.findIndex(t=>t.index===e);-1!==o&&(i[o].success=!1,i[o].message=`Failed to delete: ${t}`)}o.send({type:"delete_cells_by_number_response",request_id:c,success:!0,deleted_count:p,total_requested:r.length,results:i,message:`Deleted ${p} cell(s)`}),console.log(`MCP Active Cell Bridge: Deleted ${p} cells by number`)}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cells by number:",e),o.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:`Failed to delete cells: ${e}`})}})(0,n,c):"move_cursor"===r?(async(e,o,s)=>{var n;const l=s.request_id,c=s.target;try{const e=t.currentWidget,s=null==e?void 0:e.content;if(!e||!s)return void o.send({type:"move_cursor_response",request_id:l,success:!1,message:"No active notebook available"});const r=null===(n=s.model)||void 0===n?void 0:n.cells;if(!r||0===r.length)return void o.send({type:"move_cursor_response",request_id:l,success:!1,message:"No cells in notebook"});const d=s.activeCellIndex;let a;if("above"===c)a=d-1;else if("below"===c)a=d+1;else{const e=parseInt(c);if(isNaN(e))return void o.send({type:"move_cursor_response",request_id:l,success:!1,message:`Invalid target '${c}'. Must be 'above', 'below', or a cell number`});let t=!1;for(let o=0;o<r.length;o++)if(r.get(o).executionCount===e){a=o,t=!0;break}if(!t)return void o.send({type:"move_cursor_response",request_id:l,success:!1,message:`Cell with execution count ${e} not found`})}a=Math.max(0,Math.min(a,r.length-1)),s.activeCellIndex=a;const i=s.activeCell;i&&s.scrollToCell(i),o.send({type:"move_cursor_response",request_id:l,success:!0,old_index:d,new_index:a,message:`Cursor moved from index ${d} to ${a}`}),console.log(`MCP Active Cell Bridge: Moved cursor from ${d} to ${a}`)}catch(e){console.error("MCP Active Cell Bridge: Failed to move cursor:",e),o.send({type:"move_cursor_response",request_id:l,success:!1,message:`Failed to move cursor: ${e}`})}})(0,n,c):"get_cell_outputs"===r?(async(e,o,s)=>{var n;const l=s.request_id,c=s.cell_numbers||[];try{const e=t.currentWidget;if(!e)return void o.send({type:"get_cell_outputs_response",request_id:l,success:!1,message:"No active notebook available"});const s=null===(n=e.content.model)||void 0===n?void 0:n.cells;if(!s)return void o.send({type:"get_cell_outputs_response",request_id:l,success:!1,message:"Cannot access notebook cells"});const r=new Map;for(let e=0;e<s.length;e++){const t=s.get(e),o=t.executionCount;null!=o&&"code"===t.type&&r.set(o,t)}const d={};for(const e of c){const t=r.get(e);if(!t){d[e]={success:!1,message:`Cell with execution count ${e} not found`};continue}const o=t.outputs,s=[];if(o&&o.length>0)for(let e=0;e<o.length;e++){const t=o.get(e),n=t.type;if("stream"===n){const e=t._raw||{},o=e.name||"stdout";let n=e.text;!n&&t._text&&(n=t._text._text||t._text),Array.isArray(n)&&(n=n.join("")),s.push({type:"stream",name:o,text:n||""})}else if("execute_result"===n){const e=t._rawData||t.data||{};s.push({type:"execute_result",execution_count:t.executionCount,data:e})}else if("display_data"===n){const e=t._rawData||t.data||{};s.push({type:"display_data",data:e})}else if("error"===n){const e=t._raw||{};s.push({type:"error",ename:e.ename||t.ename||"",evalue:e.evalue||t.evalue||"",traceback:e.traceback||t.traceback||[]})}}d[e]={success:!0,execution_count:e,has_output:s.length>0,outputs:s}}o.send({type:"get_cell_outputs_response",request_id:l,success:!0,outputs:d,message:`Retrieved outputs for ${Object.keys(d).length} cell(s)`}),console.log(`MCP Active Cell Bridge: Retrieved outputs for ${c.length} cell(s)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to get cell outputs:",e),o.send({type:"get_cell_outputs_response",request_id:l,success:!1,message:`Failed to get cell outputs: ${e}`})}})(0,n,c):"apply_patch"===r?(async(e,o,s)=>{const n=s.request_id,l=s.old_text||"",c=s.new_text||"";try{const e=t.currentWidget,s=t.activeCell;if(!e||!s)return void o.send({type:"apply_patch_response",request_id:n,success:!1,message:"No active cell available for patching"});if(!l)return void o.send({type:"apply_patch_response",request_id:n,success:!1,message:"old_text parameter cannot be empty"});const r=s.model.sharedModel.getSource(),d=r.replace(l,c);d!==r?(s.model.sharedModel.setSource(d),o.send({type:"apply_patch_response",request_id:n,success:!0,cell_id:s.model.id,replaced:!0,old_text_length:l.length,new_text_length:c.length,content_length_before:r.length,content_length_after:d.length,message:"Patch applied successfully"}),console.log(`MCP Active Cell Bridge: Applied patch (${l.length} -> ${c.length} chars)`)):(o.send({type:"apply_patch_response",request_id:n,success:!0,cell_id:s.model.id,replaced:!1,old_text_length:l.length,new_text_length:c.length,message:"Patch target not found - no changes made"}),console.log("MCP Active Cell Bridge: Patch target not found"))}catch(e){console.error("MCP Active Cell Bridge: Failed to apply patch:",e),o.send({type:"apply_patch_response",request_id:n,success:!1,message:`Failed to apply patch: ${e}`})}})(0,n,c):console.warn(`MCP Active Cell Bridge: Unknown message type: ${r}`)},n.onClose=t=>{console.log("MCP Active Cell Bridge: Comm closed"),r.delete(e),o.delete(e),d.delete(e)},await n.open({}).done,r.set(e,!0),o.set(e,n),n}catch(t){console.error("MCP Active Cell Bridge: Failed to create comm:",t);const s=(null==t?void 0:t.toString())||"";throw(s.includes("No such comm target")||s.includes("comm target"))&&console.log("MCP Active Cell Bridge: Server not started yet. Use %mcp_start to start the server."),r.delete(e),o.delete(e),t}finally{d.delete(e)}})(),d.set(e,l),await l}return n},y=async s=>{var n,l,c,a,i,u,g;const v=t.currentWidget,_=t.activeCell;if(!v||!_)return;const y=null!=s?s:null===(n=v.sessionContext.session)||void 0===n?void 0:n.kernel;if(!y)return;const h=await m(y);if(h&&p(y,h))try{const t=_.editor,o=_.model.sharedModel.getSource();let s=null;try{s=null!==(c=null===(l=null==t?void 0:t.getCursorPosition)||void 0===l?void 0:l.call(t))&&void 0!==c?c:null}catch(e){}let n=null;try{const e=null!==(i=null===(a=null==t?void 0:t.getSelection)||void 0===a?void 0:a.call(t))&&void 0!==i?i:null;e&&e.start!==e.end&&(n={start:e.start,end:e.end})}catch(e){}const r=5e4;let d=o,p=!1;o.length>r&&(d=o.slice(0,r),p=!0);const m={type:"snapshot",path:v.context.path,index:v.content.activeCellIndex,id:_.model.id,cell_type:_.model.type,text:d,cursor:s,selection:n,truncated:p,original_length:o.length,ts_ms:Date.now(),client_id:null!==(g=null===(u=e.info)||void 0===u?void 0:u.workspace)&&void 0!==g?g:"unknown"};h.send(m),console.log(`MCP Active Cell Bridge: Sent snapshot (${d.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to send snapshot:",e),o.delete(y),r.delete(y),d.delete(y)}else console.warn("MCP Active Cell Bridge: Comm not ready for sending")};t.activeCellChanged.connect(async(e,o)=>{var s,n,l;const c=null!==(l=null===(n=null===(s=t.currentWidget)||void 0===s?void 0:s.sessionContext.session)||void 0===n?void 0:n.kernel)&&void 0!==l?l:null;await m(c),await y(c);const r=t.activeCell;if(r){const e=(e=>{let t=null;return()=>{t&&window.clearTimeout(t),t=window.setTimeout(e,2e3)}})(()=>y(c));r.model.sharedModel.changed.connect(()=>{e()}),console.log("MCP Active Cell Bridge: Tracking new active cell")}}),t.currentChanged.connect(async(e,o)=>{var s,n,l;const c=null!==(l=null===(n=null===(s=t.currentWidget)||void 0===s?void 0:s.sessionContext.session)||void 0===n?void 0:n.kernel)&&void 0!==l?l:null;await m(c),await y(c),console.log("MCP Active Cell Bridge: Notebook changed, sent snapshot")}),t.widgetAdded.connect((e,t)=>{t.sessionContext.ready.then(()=>{var e,o;const s=null!==(o=null===(e=t.sessionContext.session)||void 0===e?void 0:e.kernel)&&void 0!==o?o:null;s&&(v(s),_(s)),console.log("MCP Active Cell Bridge: Kernel ready, waiting for server status")})}),t.forEach(e=>{var t,o;const s=null!==(o=null===(t=e.sessionContext.session)||void 0===t?void 0:t.kernel)&&void 0!==o?o:null;s&&(v(s),_(s))}),console.log("MCP Active Cell Bridge: Event listeners registered")}}}}]);