"use strict";(self.webpackChunkmcp_active_cell_bridge=self.webpackChunkmcp_active_cell_bridge||[]).push([[509],{509:(e,t,l)=>{l.r(t),l.d(t,{default:()=>o});var n=l(980);const o={id:"mcp-active-cell-bridge:plugin",description:"Bridge active cell content to MCP server via kernel comm",autoStart:!0,requires:[n.INotebookTracker],activate:(e,t)=>{console.log("MCP Active Cell Bridge extension activated");const l=new WeakMap,o=new WeakMap,s=new WeakMap,c=(e,t)=>t&&!t.isDisposed&&!0===o.get(e),i=async e=>{if(!e||!e.status||"dead"===e.status)return console.warn("MCP Active Cell Bridge: Kernel not available or dead"),null;if("idle"!==e.status&&"busy"!==e.status)return console.warn(`MCP Active Cell Bridge: Kernel not ready (status: ${e.status})`),null;let i=l.get(e);if(!i||!c(e,i)){let c=s.get(e);if(c)try{return await c,l.get(e)||null}catch(e){return null}return c=(async()=>{try{return i=e.createComm("mcp:active_cell"),i.onMsg=l=>{var o;const s=(null===(o=null==l?void 0:l.content)||void 0===o?void 0:o.data)||{};"request_current"===s.type?r(e):"update_cell"===s.type?(async(e,l,n)=>{const o=n.request_id,s=n.content;try{const e=t.currentWidget,n=t.activeCell;if(!e||!n)return void l.send({type:"update_response",request_id:o,success:!1,message:"No active cell available for update"});n.model.sharedModel.setSource(s),l.send({type:"update_response",request_id:o,success:!0,cell_id:n.model.id,message:"Cell updated successfully"}),console.log(`MCP Active Cell Bridge: Updated cell content (${s.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to update cell:",e),l.send({type:"update_response",request_id:o,success:!1,message:`Failed to update cell: ${e}`})}})(0,i,s):"execute_cell"===s.type&&(async(e,l,o)=>{const s=o.request_id;try{const e=t.currentWidget,o=t.activeCell;if(!e||!o)return void l.send({type:"execute_response",request_id:s,success:!1,message:"No active cell available for execution"});await n.NotebookActions.run(e.content,e.sessionContext),l.send({type:"execute_response",request_id:s,success:!0,cell_id:o.model.id,message:"Cell executed successfully"}),console.log("MCP Active Cell Bridge: Executed active cell")}catch(e){console.error("MCP Active Cell Bridge: Failed to execute cell:",e),l.send({type:"execute_response",request_id:s,success:!1,message:`Failed to execute cell: ${e}`})}})(0,i,s)},i.onClose=t=>{console.log("MCP Active Cell Bridge: Comm closed"),o.delete(e),l.delete(e),s.delete(e)},await i.open({}).done,o.set(e,!0),l.set(e,i),console.log("MCP Active Cell Bridge: Comm opened and ready"),i}catch(t){console.error("MCP Active Cell Bridge: Failed to create comm:",t);const n=(null==t?void 0:t.toString())||"";throw(n.includes("No such comm target")||n.includes("comm target"))&&(console.error("MCP Active Cell Bridge: Kernel comm target not registered!"),console.error("Run this command in a notebook cell: %load_ext servers.jupyter_qcodes.jupyter_mcp_extension")),o.delete(e),l.delete(e),t}finally{s.delete(e)}})(),s.set(e,c),await c}return i},r=async n=>{var r,d,a,u,v,g,C;const p=t.currentWidget,m=t.activeCell;if(!p||!m)return;const y=null!=n?n:null===(r=p.sessionContext.session)||void 0===r?void 0:r.kernel;if(!y)return;const h=await i(y);if(h&&c(y,h))try{const t=m.editor,l=m.model.sharedModel.getSource();let n=null;try{n=null!==(a=null===(d=null==t?void 0:t.getCursorPosition)||void 0===d?void 0:d.call(t))&&void 0!==a?a:null}catch(e){}let o=null;try{const e=null!==(v=null===(u=null==t?void 0:t.getSelection)||void 0===u?void 0:u.call(t))&&void 0!==v?v:null;e&&e.start!==e.end&&(o={start:e.start,end:e.end})}catch(e){}const s=5e4;let c=l,i=!1;l.length>s&&(c=l.slice(0,s),i=!0);const r={type:"snapshot",path:p.context.path,index:p.content.activeCellIndex,id:m.model.id,cell_type:m.model.type,text:c,cursor:n,selection:o,truncated:i,original_length:l.length,ts_ms:Date.now(),client_id:null!==(C=null===(g=e.info)||void 0===g?void 0:g.workspace)&&void 0!==C?C:"unknown"};h.send(r),console.log(`MCP Active Cell Bridge: Sent snapshot (${c.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to send snapshot:",e),l.delete(y),o.delete(y),s.delete(y)}else console.warn("MCP Active Cell Bridge: Comm not ready for sending")};t.activeCellChanged.connect(async(e,l)=>{var n,o,s;const c=null!==(s=null===(o=null===(n=t.currentWidget)||void 0===n?void 0:n.sessionContext.session)||void 0===o?void 0:o.kernel)&&void 0!==s?s:null;await i(c),await r(c);const d=t.activeCell;if(d){const e=(e=>{let t=null;return()=>{t&&window.clearTimeout(t),t=window.setTimeout(e,2e3)}})(()=>r(c));d.model.sharedModel.changed.connect(()=>{e()}),console.log("MCP Active Cell Bridge: Tracking new active cell")}}),t.currentChanged.connect(async(e,l)=>{var n,o,s;const c=null!==(s=null===(o=null===(n=t.currentWidget)||void 0===n?void 0:n.sessionContext.session)||void 0===o?void 0:o.kernel)&&void 0!==s?s:null;await i(c),await r(c),console.log("MCP Active Cell Bridge: Notebook changed, sent snapshot")}),t.widgetAdded.connect((e,t)=>{t.sessionContext.ready.then(()=>{var e,l;const n=null!==(l=null===(e=t.sessionContext.session)||void 0===e?void 0:e.kernel)&&void 0!==l?l:null;i(n),console.log("MCP Active Cell Bridge: Kernel ready, setting up comm")})}),console.log("MCP Active Cell Bridge: Event listeners registered")}}}}]);