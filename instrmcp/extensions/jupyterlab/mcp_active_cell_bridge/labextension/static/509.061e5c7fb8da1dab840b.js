"use strict";(self.webpackChunkmcp_active_cell_bridge=self.webpackChunkmcp_active_cell_bridge||[]).push([[509],{509:(e,t,l)=>{l.r(t),l.d(t,{default:()=>n});var s=l(980);const n={id:"mcp-active-cell-bridge:plugin",description:"Bridge active cell content to MCP server via kernel comm",autoStart:!0,requires:[s.INotebookTracker],activate:(e,t)=>{console.log("MCP Active Cell Bridge extension activated");const l=new WeakMap,n=new WeakMap,o=new WeakMap,c=(e,t)=>t&&!t.isDisposed&&!0===n.get(e),d=async e=>{if(!e||!e.status||"dead"===e.status)return console.warn("MCP Active Cell Bridge: Kernel not available or dead"),null;if("idle"!==e.status&&"busy"!==e.status)return console.warn(`MCP Active Cell Bridge: Kernel not ready (status: ${e.status})`),null;let d=l.get(e);if(!d||!c(e,d)){let c=o.get(e);if(c)try{return await c,l.get(e)||null}catch(e){return null}return c=(async()=>{try{return d=e.createComm("mcp:active_cell"),d.onMsg=l=>{var n;const o=(null===(n=null==l?void 0:l.content)||void 0===n?void 0:n.data)||{},c=o.type;"request_current"===c?i(e):"update_cell"===c?(async(e,l,s)=>{const n=s.request_id,o=s.content;try{const e=t.currentWidget,s=t.activeCell;if(!e||!s)return void l.send({type:"update_response",request_id:n,success:!1,message:"No active cell available for update"});s.model.sharedModel.setSource(o),l.send({type:"update_response",request_id:n,success:!0,cell_id:s.model.id,message:"Cell updated successfully"}),console.log(`MCP Active Cell Bridge: Updated cell content (${o.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to update cell:",e),l.send({type:"update_response",request_id:n,success:!1,message:`Failed to update cell: ${e}`})}})(0,d,o):"execute_cell"===c?(async(e,l,n)=>{const o=n.request_id;try{const e=t.currentWidget,n=t.activeCell;if(!e||!n)return void l.send({type:"execute_response",request_id:o,success:!1,message:"No active cell available for execution"});await s.NotebookActions.run(e.content,e.sessionContext),l.send({type:"execute_response",request_id:o,success:!0,cell_id:n.model.id,message:"Cell executed successfully"}),console.log("MCP Active Cell Bridge: Executed active cell")}catch(e){console.error("MCP Active Cell Bridge: Failed to execute cell:",e),l.send({type:"execute_response",request_id:o,success:!1,message:`Failed to execute cell: ${e}`})}})(0,d,o):"add_cell"===c?(async(e,l,n)=>{const o=n.request_id,c=n.cell_type||"code",d=n.position||"below",i=n.content||"";try{const e=t.currentWidget;if(!e)return void l.send({type:"add_cell_response",request_id:o,success:!1,message:"No active notebook available"});const n=["code","markdown","raw"];if(!n.includes(c))return void l.send({type:"add_cell_response",request_id:o,success:!1,message:`Invalid cell_type '${c}'. Must be one of: ${n.join(", ")}`});const r=["above","below"];if(!r.includes(d))return void l.send({type:"add_cell_response",request_id:o,success:!1,message:`Invalid position '${d}'. Must be one of: ${r.join(", ")}`});"above"===d?await s.NotebookActions.insertAbove(e.content):await s.NotebookActions.insertBelow(e.content);const a=t.activeCell;a&&(a.model.type!==c&&await s.NotebookActions.changeCellType(e.content,c),i&&a.model.sharedModel.setSource(i)),l.send({type:"add_cell_response",request_id:o,success:!0,cell_type:c,position:d,content_length:i.length,cell_id:null==a?void 0:a.model.id,message:"Cell added successfully"}),console.log(`MCP Active Cell Bridge: Added ${c} cell ${d} with ${i.length} chars`)}catch(e){console.error("MCP Active Cell Bridge: Failed to add cell:",e),l.send({type:"add_cell_response",request_id:o,success:!1,message:`Failed to add cell: ${e}`})}})(0,d,o):"delete_cell"===c?(async(e,l,n)=>{var o;const c=n.request_id;try{const e=t.currentWidget,n=t.activeCell;if(!e||!n)return void l.send({type:"delete_cell_response",request_id:c,success:!1,message:"No active cell available for deletion"});const d=n.model.id;((null===(o=e.content.model)||void 0===o?void 0:o.cells.length)||0)<=1?(n.model.sharedModel.setSource(""),l.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:d,action:"cleared",message:"Last cell content cleared (cell preserved)"}),console.log("MCP Active Cell Bridge: Cleared last cell content")):(await s.NotebookActions.deleteCells(e.content),l.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:d,action:"deleted",message:"Cell deleted successfully"}),console.log("MCP Active Cell Bridge: Deleted cell"))}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cell:",e),l.send({type:"delete_cell_response",request_id:c,success:!1,message:`Failed to delete cell: ${e}`})}})(0,d,o):"delete_cells_by_number"===c?(async(e,l,s)=>{var n,o;const c=s.request_id,d=s.cell_numbers||[];try{const e=t.currentWidget;if(!e)return void l.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"No active notebook available"});if(!Array.isArray(d)||0===d.length)return void l.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"cell_numbers must be a non-empty array"});const s=e.content,i=null===(n=s.model)||void 0===n?void 0:n.cells;if(!i)return void l.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"Cannot access notebook cells"});const r=new Map;for(let e=0;e<i.length;e++){const t=i.get(e).executionCount;null!=t&&r.set(t,e)}const a=[],u=[];for(const e of d)if(r.has(e)){const t=r.get(e);u.push(t),a.push({cell_number:e,index:t,success:!0})}else a.push({cell_number:e,success:!1,message:`Cell with execution count ${e} not found`});u.sort((e,t)=>t-e);let g=0,_=0;for(const e of u)try{if(1===i.length){const t=i.get(e);if(t){t.sharedModel.setSource("");const l=a.findIndex(t=>t.index===e);-1!==l&&(a[l].message="Last cell - content cleared instead of deleted",a[l].cleared=!0),_++}}else null===(o=s.model)||void 0===o||o.sharedModel.deleteCell(e),g++}catch(t){const l=a.findIndex(t=>t.index===e);-1!==l&&(a[l].success=!1,a[l].message=`Failed to delete: ${t}`)}l.send({type:"delete_cells_by_number_response",request_id:c,success:!0,deleted_count:g,total_requested:d.length,results:a,message:`Deleted ${g} cell(s)`}),console.log(`MCP Active Cell Bridge: Deleted ${g} cells by number`)}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cells by number:",e),l.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:`Failed to delete cells: ${e}`})}})(0,d,o):"apply_patch"===c?(async(e,l,s)=>{const n=s.request_id,o=s.old_text||"",c=s.new_text||"";try{const e=t.currentWidget,s=t.activeCell;if(!e||!s)return void l.send({type:"apply_patch_response",request_id:n,success:!1,message:"No active cell available for patching"});if(!o)return void l.send({type:"apply_patch_response",request_id:n,success:!1,message:"old_text parameter cannot be empty"});const d=s.model.sharedModel.getSource(),i=d.replace(o,c);i!==d?(s.model.sharedModel.setSource(i),l.send({type:"apply_patch_response",request_id:n,success:!0,cell_id:s.model.id,replaced:!0,old_text_length:o.length,new_text_length:c.length,content_length_before:d.length,content_length_after:i.length,message:"Patch applied successfully"}),console.log(`MCP Active Cell Bridge: Applied patch (${o.length} -> ${c.length} chars)`)):(l.send({type:"apply_patch_response",request_id:n,success:!0,cell_id:s.model.id,replaced:!1,old_text_length:o.length,new_text_length:c.length,message:"Patch target not found - no changes made"}),console.log("MCP Active Cell Bridge: Patch target not found"))}catch(e){console.error("MCP Active Cell Bridge: Failed to apply patch:",e),l.send({type:"apply_patch_response",request_id:n,success:!1,message:`Failed to apply patch: ${e}`})}})(0,d,o):console.warn(`MCP Active Cell Bridge: Unknown message type: ${c}`)},d.onClose=t=>{console.log("MCP Active Cell Bridge: Comm closed"),n.delete(e),l.delete(e),o.delete(e)},await d.open({}).done,n.set(e,!0),l.set(e,d),d}catch(t){console.error("MCP Active Cell Bridge: Failed to create comm:",t);const s=(null==t?void 0:t.toString())||"";throw(s.includes("No such comm target")||s.includes("comm target"))&&(console.error("MCP Active Cell Bridge: Kernel comm target not registered!"),console.error("Run this command in a notebook cell: %load_ext servers.jupyter_qcodes.jupyter_mcp_extension")),n.delete(e),l.delete(e),t}finally{o.delete(e)}})(),o.set(e,c),await c}return d},i=async s=>{var i,r,a,u,g,_,p;const v=t.currentWidget,m=t.activeCell;if(!v||!m)return;const y=null!=s?s:null===(i=v.sessionContext.session)||void 0===i?void 0:i.kernel;if(!y)return;const C=await d(y);if(C&&c(y,C))try{const t=m.editor,l=m.model.sharedModel.getSource();let s=null;try{s=null!==(a=null===(r=null==t?void 0:t.getCursorPosition)||void 0===r?void 0:r.call(t))&&void 0!==a?a:null}catch(e){}let n=null;try{const e=null!==(g=null===(u=null==t?void 0:t.getSelection)||void 0===u?void 0:u.call(t))&&void 0!==g?g:null;e&&e.start!==e.end&&(n={start:e.start,end:e.end})}catch(e){}const o=5e4;let c=l,d=!1;l.length>o&&(c=l.slice(0,o),d=!0);const i={type:"snapshot",path:v.context.path,index:v.content.activeCellIndex,id:m.model.id,cell_type:m.model.type,text:c,cursor:s,selection:n,truncated:d,original_length:l.length,ts_ms:Date.now(),client_id:null!==(p=null===(_=e.info)||void 0===_?void 0:_.workspace)&&void 0!==p?p:"unknown"};C.send(i),console.log(`MCP Active Cell Bridge: Sent snapshot (${c.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to send snapshot:",e),l.delete(y),n.delete(y),o.delete(y)}else console.warn("MCP Active Cell Bridge: Comm not ready for sending")};t.activeCellChanged.connect(async(e,l)=>{var s,n,o;const c=null!==(o=null===(n=null===(s=t.currentWidget)||void 0===s?void 0:s.sessionContext.session)||void 0===n?void 0:n.kernel)&&void 0!==o?o:null;await d(c),await i(c);const r=t.activeCell;if(r){const e=(e=>{let t=null;return()=>{t&&window.clearTimeout(t),t=window.setTimeout(e,2e3)}})(()=>i(c));r.model.sharedModel.changed.connect(()=>{e()}),console.log("MCP Active Cell Bridge: Tracking new active cell")}}),t.currentChanged.connect(async(e,l)=>{var s,n,o;const c=null!==(o=null===(n=null===(s=t.currentWidget)||void 0===s?void 0:s.sessionContext.session)||void 0===n?void 0:n.kernel)&&void 0!==o?o:null;await d(c),await i(c),console.log("MCP Active Cell Bridge: Notebook changed, sent snapshot")}),t.widgetAdded.connect((e,t)=>{t.sessionContext.ready.then(()=>{var e,l;const s=null!==(l=null===(e=t.sessionContext.session)||void 0===e?void 0:e.kernel)&&void 0!==l?l:null;d(s),console.log("MCP Active Cell Bridge: Kernel ready, setting up comm")})}),console.log("MCP Active Cell Bridge: Event listeners registered")}}}}]);