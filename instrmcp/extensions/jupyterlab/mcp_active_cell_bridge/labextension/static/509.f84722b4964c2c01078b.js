"use strict";(self.webpackChunkmcp_active_cell_bridge=self.webpackChunkmcp_active_cell_bridge||[]).push([[509],{509:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});var o=n(980),l=n(436),s=n(256),c=n(188);const d={id:"mcp-active-cell-bridge:plugin",description:"Bridge active cell content to MCP server and handle consent dialogs",autoStart:!0,requires:[o.INotebookTracker],activate:(e,t)=>{console.log("MCP Active Cell Bridge extension activated");const n=new WeakMap,d=new WeakMap,r=new WeakMap,i=new WeakMap,a=(e,t)=>t&&!t.isDisposed&&!0===d.get(e),u=e=>{const t=document.createElement("div");return t.textContent=e,t.innerHTML},p=e=>{e&&e.status&&"dead"!==e.status&&(e.registerCommTarget("mcp:capcall",(t,n)=>{console.log("MCP Consent: Backend opened consent comm channel");let o=i.get(e);o||(o=new Set,i.set(e,o)),o.add(t),t.onMsg=e=>{var n;const o=(null===(n=null==e?void 0:e.content)||void 0===n?void 0:n.data)||{},d=o.type;"consent_request"===d?"apply_patch"===(o.operation||"unknown")?(async(e,t,n)=>{n.operation;const o=n.tool_name||"notebook_apply_patch",d=(n.author,n.details||{});console.log(`MCP Consent: Received patch consent request for tool '${o}'`);try{const e=document.createElement("div");e.style.maxWidth="700px";const n=document.createElement("div");n.style.marginBottom="15px",n.innerHTML=`\n          <div style="margin-bottom: 10px;">\n            <strong>Cell Type:</strong> ${d.cell_type||"code"}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Cell Index:</strong> ${d.cell_index||"unknown"}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Description:</strong> ${d.description||"Apply text patch to current cell"}\n          </div>\n        `,e.appendChild(n);const o=document.createElement("div");o.style.marginBottom="15px",o.style.padding="10px",o.style.background="#f5f5f5",o.style.borderRadius="4px";const r=(d.old_text||"").length,i=(d.new_text||"").length,a=i-r,p=a>=0?"+":"";o.innerHTML=`\n          <div style="display: flex; gap: 20px; font-size: 13px;">\n            <div><strong>Remove:</strong> <span style="color: #d32f2f;">${r} chars</span></div>\n            <div><strong>Add:</strong> <span style="color: #388e3c;">${i} chars</span></div>\n            <div><strong>Delta:</strong> <span style="color: ${a>=0?"#388e3c":"#d32f2f"};">${p}${a} chars</span></div>\n          </div>\n        `,e.appendChild(o);const g=document.createElement("div");g.style.marginTop="15px";const v=document.createElement("div");v.innerHTML="<strong>Changes Preview:</strong>",v.style.marginBottom="8px",g.appendChild(v);const{html:m,found:y}=((e,t,n)=>{if(-1===e.indexOf(t))return{html:'<div style="color: #d32f2f; padding: 10px; background: #ffebee; border-radius: 4px;">\n            <strong>⚠️ Warning:</strong> Pattern not found in current cell content.\n          </div>',found:!1};const o=e.replace(t,n),l=(0,c.diffLines)(e,o);let s='<div style="font-family: monospace; font-size: 12px; line-height: 1.4;">',d=1;for(const e of l){const t=e.value.split("\n");""===t[t.length-1]&&t.pop();for(let n=0;n<t.length;n++){const o=t[n];e.added?s+=`<div style="background: #e8f5e9; padding: 2px 8px; border-left: 3px solid #66bb6a;">\n              <span style="color: #999; margin-right: 8px;">+</span><span style="background: #a5d6a7;">${u(o)}</span>\n            </div>`:e.removed?s+=`<div style="background: #ffebee; padding: 2px 8px; border-left: 3px solid #ef5350;">\n              <span style="color: #999; margin-right: 8px;">-</span><span style="background: #ef9a9a; text-decoration: line-through;">${u(o)}</span>\n            </div>`:(s+=`<div style="color: #666; background: #f8f9fa; padding: 2px 8px; border-left: 3px solid #e0e0e0;">\n              <span style="color: #999; margin-right: 8px;">${d}</span>${u(o)}\n            </div>`,d++)}}return s+="</div>",{html:s,found:!0}})(d.cell_content||"",d.old_text||"",d.new_text||""),_=document.createElement("div");if(_.style.maxHeight="400px",_.style.overflow="auto",_.style.border="1px solid #ddd",_.style.borderRadius="4px",_.style.background="white",_.innerHTML=m,g.appendChild(_),e.appendChild(g),!y){const t=document.createElement("div");t.style.marginTop="10px",t.style.padding="10px",t.style.background="#fff3cd",t.style.border="1px solid #ffc107",t.style.borderRadius="4px",t.style.color="#856404",t.innerHTML="\n            <strong>⚠️ Warning:</strong> The pattern to be replaced was not found in the current cell content.\n            The patch will have no effect if you proceed.\n          ",e.appendChild(t)}const h=new s.Widget({node:e}),C=await(0,l.showDialog)({title:"Apply Patch Consent",body:h,buttons:[l.Dialog.cancelButton({label:"Decline"}),l.Dialog.okButton({label:"Allow"}),l.Dialog.warnButton({label:"Always Allow"})],defaultButton:1});let f=!1,b=!1,x="";"Allow"===C.button.label?(f=!0,b=!1,x="User approved patch"):"Always Allow"===C.button.label?(f=!0,b=!0,x="User approved patch with always allow"):(f=!1,b=!1,x="User declined patch"),t.send({type:"consent_response",approved:f,always_allow:b,reason:x}),console.log(`MCP Consent: Sent patch response - approved: ${f}`)}catch(e){console.error("MCP Consent: Failed to show patch consent dialog:",e),t.send({type:"consent_response",approved:!1,always_allow:!1,reason:`Dialog error: ${e}`})}})(0,t,o):(async(e,t,n)=>{const o=n.operation||"unknown",c=n.tool_name||"Unnamed Tool",d=n.author||"Unknown Author",r=n.details||{};console.log(`MCP Consent: Received consent request for ${o} of tool '${c}' by '${d}'`);try{const e=document.createElement("div");e.style.maxWidth="600px";const n=document.createElement("div");if(n.style.marginBottom="15px",n.innerHTML=`\n          <div style="margin-bottom: 10px;">\n            <strong>Operation:</strong> ${o}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Tool:</strong> ${c}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Author:</strong> ${d}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Version:</strong> ${r.version||"N/A"}\n          </div>\n          <div style="margin-bottom: 10px;">\n            <strong>Description:</strong> ${r.description||"No description provided"}\n          </div>\n        `,r.capabilities&&r.capabilities.length>0){const e=document.createElement("div");e.style.marginBottom="10px",e.innerHTML=`\n            <div style="margin-bottom: 5px;"><strong>Capabilities:</strong></div>\n            <ul style="margin: 0; padding-left: 20px;">\n              ${r.capabilities.map(e=>`<li>${e}</li>`).join("")}\n            </ul>\n          `,n.appendChild(e)}if(e.appendChild(n),r.source_code){const t=document.createElement("div");t.style.marginTop="15px";const n=document.createElement("div");n.innerHTML="<strong>Source Code:</strong>",n.style.marginBottom="5px",t.appendChild(n);const o=document.createElement("pre");o.style.maxHeight="300px",o.style.overflow="auto",o.style.padding="10px",o.style.backgroundColor="#f5f5f5",o.style.border="1px solid #ddd",o.style.borderRadius="4px",o.style.fontSize="12px",o.style.fontFamily="monospace",o.textContent=r.source_code,t.appendChild(o),e.appendChild(t)}const i=new s.Widget({node:e}),a=await(0,l.showDialog)({title:`Tool ${o.charAt(0).toUpperCase()+o.slice(1)} Consent`,body:i,buttons:[l.Dialog.cancelButton({label:"Decline"}),l.Dialog.okButton({label:"Allow"}),l.Dialog.warnButton({label:"Always Allow"})],defaultButton:1});let u=!1,p=!1,g="";"Allow"===a.button.label?(u=!0,p=!1,g="User approved"):"Always Allow"===a.button.label?(u=!0,p=!0,g="User approved with always allow"):(u=!1,p=!1,g="User declined"),t.send({type:"consent_response",approved:u,always_allow:p,reason:g}),console.log(`MCP Consent: Sent response - approved: ${u}, always_allow: ${p}`)}catch(e){console.error("MCP Consent: Failed to show consent dialog:",e),t.send({type:"consent_response",approved:!1,always_allow:!1,reason:`Dialog error: ${e}`})}})(0,t,o):console.warn(`MCP Consent: Unknown message type: ${d}`)},t.onClose=n=>{console.log("MCP Consent: Comm closed by backend");const o=i.get(e);o&&o.delete(t)}}),console.log("MCP Consent: Registered comm target mcp:capcall"))},g=async e=>{if(!e||!e.status||"dead"===e.status)return console.warn("MCP Active Cell Bridge: Kernel not available or dead"),null;if("idle"!==e.status&&"busy"!==e.status)return console.warn(`MCP Active Cell Bridge: Kernel not ready (status: ${e.status})`),null;let l=n.get(e);if(!l||!a(e,l)){let s=r.get(e);if(s)try{return await s,n.get(e)||null}catch(e){return null}return s=(async()=>{try{return l=e.createComm("mcp:active_cell"),l.onMsg=n=>{var s;const c=(null===(s=null==n?void 0:n.content)||void 0===s?void 0:s.data)||{},d=c.type;"request_current"===d?v(e):"update_cell"===d?(async(e,n,o)=>{const l=o.request_id,s=o.content;try{const e=t.currentWidget,o=t.activeCell;if(!e||!o)return void n.send({type:"update_response",request_id:l,success:!1,message:"No active cell available for update"});o.model.sharedModel.setSource(s),n.send({type:"update_response",request_id:l,success:!0,cell_id:o.model.id,message:"Cell updated successfully"}),console.log(`MCP Active Cell Bridge: Updated cell content (${s.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to update cell:",e),n.send({type:"update_response",request_id:l,success:!1,message:`Failed to update cell: ${e}`})}})(0,l,c):"execute_cell"===d?(async(e,n,l)=>{const s=l.request_id;try{const e=t.currentWidget,l=t.activeCell;if(!e||!l)return void n.send({type:"execute_response",request_id:s,success:!1,message:"No active cell available for execution"});await o.NotebookActions.run(e.content,e.sessionContext),n.send({type:"execute_response",request_id:s,success:!0,cell_id:l.model.id,message:"Cell executed successfully"}),console.log("MCP Active Cell Bridge: Executed active cell")}catch(e){console.error("MCP Active Cell Bridge: Failed to execute cell:",e),n.send({type:"execute_response",request_id:s,success:!1,message:`Failed to execute cell: ${e}`})}})(0,l,c):"add_cell"===d?(async(e,n,l)=>{const s=l.request_id,c=l.cell_type||"code",d=l.position||"below",r=l.content||"";try{const e=t.currentWidget;if(!e)return void n.send({type:"add_cell_response",request_id:s,success:!1,message:"No active notebook available"});const l=["code","markdown","raw"];if(!l.includes(c))return void n.send({type:"add_cell_response",request_id:s,success:!1,message:`Invalid cell_type '${c}'. Must be one of: ${l.join(", ")}`});const i=["above","below"];if(!i.includes(d))return void n.send({type:"add_cell_response",request_id:s,success:!1,message:`Invalid position '${d}'. Must be one of: ${i.join(", ")}`});"above"===d?await o.NotebookActions.insertAbove(e.content):await o.NotebookActions.insertBelow(e.content);const a=t.activeCell;a&&(a.model.type!==c&&await o.NotebookActions.changeCellType(e.content,c),r&&a.model.sharedModel.setSource(r)),n.send({type:"add_cell_response",request_id:s,success:!0,cell_type:c,position:d,content_length:r.length,cell_id:null==a?void 0:a.model.id,message:"Cell added successfully"}),console.log(`MCP Active Cell Bridge: Added ${c} cell ${d} with ${r.length} chars`)}catch(e){console.error("MCP Active Cell Bridge: Failed to add cell:",e),n.send({type:"add_cell_response",request_id:s,success:!1,message:`Failed to add cell: ${e}`})}})(0,l,c):"delete_cell"===d?(async(e,n,l)=>{var s;const c=l.request_id;try{const e=t.currentWidget,l=t.activeCell;if(!e||!l)return void n.send({type:"delete_cell_response",request_id:c,success:!1,message:"No active cell available for deletion"});const d=l.model.id;((null===(s=e.content.model)||void 0===s?void 0:s.cells.length)||0)<=1?(l.model.sharedModel.setSource(""),n.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:d,action:"cleared",message:"Last cell content cleared (cell preserved)"}),console.log("MCP Active Cell Bridge: Cleared last cell content")):(await o.NotebookActions.deleteCells(e.content),n.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:d,action:"deleted",message:"Cell deleted successfully"}),console.log("MCP Active Cell Bridge: Deleted cell"))}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cell:",e),n.send({type:"delete_cell_response",request_id:c,success:!1,message:`Failed to delete cell: ${e}`})}})(0,l,c):"delete_cells_by_number"===d?(async(e,n,o)=>{var l,s;const c=o.request_id,d=o.cell_numbers||[];try{const e=t.currentWidget;if(!e)return void n.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"No active notebook available"});if(!Array.isArray(d)||0===d.length)return void n.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"cell_numbers must be a non-empty array"});const o=e.content,r=null===(l=o.model)||void 0===l?void 0:l.cells;if(!r)return void n.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"Cannot access notebook cells"});const i=new Map;for(let e=0;e<r.length;e++){const t=r.get(e).executionCount;null!=t&&i.set(t,e)}const a=[],u=[];for(const e of d)if(i.has(e)){const t=i.get(e);u.push(t),a.push({cell_number:e,index:t,success:!0})}else a.push({cell_number:e,success:!1,message:`Cell with execution count ${e} not found`});u.sort((e,t)=>t-e);let p=0,g=0;for(const e of u)try{if(1===r.length){const t=r.get(e);if(t){t.sharedModel.setSource("");const n=a.findIndex(t=>t.index===e);-1!==n&&(a[n].message="Last cell - content cleared instead of deleted",a[n].cleared=!0),g++}}else null===(s=o.model)||void 0===s||s.sharedModel.deleteCell(e),p++}catch(t){const n=a.findIndex(t=>t.index===e);-1!==n&&(a[n].success=!1,a[n].message=`Failed to delete: ${t}`)}n.send({type:"delete_cells_by_number_response",request_id:c,success:!0,deleted_count:p,total_requested:d.length,results:a,message:`Deleted ${p} cell(s)`}),console.log(`MCP Active Cell Bridge: Deleted ${p} cells by number`)}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cells by number:",e),n.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:`Failed to delete cells: ${e}`})}})(0,l,c):"move_cursor"===d?(async(e,n,o)=>{var l;const s=o.request_id,c=o.target;try{const e=t.currentWidget,o=null==e?void 0:e.content;if(!e||!o)return void n.send({type:"move_cursor_response",request_id:s,success:!1,message:"No active notebook available"});const d=null===(l=o.model)||void 0===l?void 0:l.cells;if(!d||0===d.length)return void n.send({type:"move_cursor_response",request_id:s,success:!1,message:"No cells in notebook"});const r=o.activeCellIndex;let i;if("above"===c)i=r-1;else if("below"===c)i=r+1;else{const e=parseInt(c);if(isNaN(e))return void n.send({type:"move_cursor_response",request_id:s,success:!1,message:`Invalid target '${c}'. Must be 'above', 'below', or a cell number`});let t=!1;for(let n=0;n<d.length;n++)if(d.get(n).executionCount===e){i=n,t=!0;break}if(!t)return void n.send({type:"move_cursor_response",request_id:s,success:!1,message:`Cell with execution count ${e} not found`})}i=Math.max(0,Math.min(i,d.length-1)),o.activeCellIndex=i;const a=o.activeCell;a&&o.scrollToCell(a),n.send({type:"move_cursor_response",request_id:s,success:!0,old_index:r,new_index:i,message:`Cursor moved from index ${r} to ${i}`}),console.log(`MCP Active Cell Bridge: Moved cursor from ${r} to ${i}`)}catch(e){console.error("MCP Active Cell Bridge: Failed to move cursor:",e),n.send({type:"move_cursor_response",request_id:s,success:!1,message:`Failed to move cursor: ${e}`})}})(0,l,c):"apply_patch"===d?(async(e,n,o)=>{const l=o.request_id,s=o.old_text||"",c=o.new_text||"";try{const e=t.currentWidget,o=t.activeCell;if(!e||!o)return void n.send({type:"apply_patch_response",request_id:l,success:!1,message:"No active cell available for patching"});if(!s)return void n.send({type:"apply_patch_response",request_id:l,success:!1,message:"old_text parameter cannot be empty"});const d=o.model.sharedModel.getSource(),r=d.replace(s,c);r!==d?(o.model.sharedModel.setSource(r),n.send({type:"apply_patch_response",request_id:l,success:!0,cell_id:o.model.id,replaced:!0,old_text_length:s.length,new_text_length:c.length,content_length_before:d.length,content_length_after:r.length,message:"Patch applied successfully"}),console.log(`MCP Active Cell Bridge: Applied patch (${s.length} -> ${c.length} chars)`)):(n.send({type:"apply_patch_response",request_id:l,success:!0,cell_id:o.model.id,replaced:!1,old_text_length:s.length,new_text_length:c.length,message:"Patch target not found - no changes made"}),console.log("MCP Active Cell Bridge: Patch target not found"))}catch(e){console.error("MCP Active Cell Bridge: Failed to apply patch:",e),n.send({type:"apply_patch_response",request_id:l,success:!1,message:`Failed to apply patch: ${e}`})}})(0,l,c):console.warn(`MCP Active Cell Bridge: Unknown message type: ${d}`)},l.onClose=t=>{console.log("MCP Active Cell Bridge: Comm closed"),d.delete(e),n.delete(e),r.delete(e)},await l.open({}).done,d.set(e,!0),n.set(e,l),l}catch(t){console.error("MCP Active Cell Bridge: Failed to create comm:",t);const o=(null==t?void 0:t.toString())||"";throw(o.includes("No such comm target")||o.includes("comm target"))&&(console.error("MCP Active Cell Bridge: Kernel comm target not registered!"),console.error("Run this command in a notebook cell: %load_ext servers.jupyter_qcodes.jupyter_mcp_extension")),d.delete(e),n.delete(e),t}finally{r.delete(e)}})(),r.set(e,s),await s}return l},v=async o=>{var l,s,c,i,u,p,v;const m=t.currentWidget,y=t.activeCell;if(!m||!y)return;const _=null!=o?o:null===(l=m.sessionContext.session)||void 0===l?void 0:l.kernel;if(!_)return;const h=await g(_);if(h&&a(_,h))try{const t=y.editor,n=y.model.sharedModel.getSource();let o=null;try{o=null!==(c=null===(s=null==t?void 0:t.getCursorPosition)||void 0===s?void 0:s.call(t))&&void 0!==c?c:null}catch(e){}let l=null;try{const e=null!==(u=null===(i=null==t?void 0:t.getSelection)||void 0===i?void 0:i.call(t))&&void 0!==u?u:null;e&&e.start!==e.end&&(l={start:e.start,end:e.end})}catch(e){}const d=5e4;let r=n,a=!1;n.length>d&&(r=n.slice(0,d),a=!0);const g={type:"snapshot",path:m.context.path,index:m.content.activeCellIndex,id:y.model.id,cell_type:y.model.type,text:r,cursor:o,selection:l,truncated:a,original_length:n.length,ts_ms:Date.now(),client_id:null!==(v=null===(p=e.info)||void 0===p?void 0:p.workspace)&&void 0!==v?v:"unknown"};h.send(g),console.log(`MCP Active Cell Bridge: Sent snapshot (${r.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to send snapshot:",e),n.delete(_),d.delete(_),r.delete(_)}else console.warn("MCP Active Cell Bridge: Comm not ready for sending")};t.activeCellChanged.connect(async(e,n)=>{var o,l,s;const c=null!==(s=null===(l=null===(o=t.currentWidget)||void 0===o?void 0:o.sessionContext.session)||void 0===l?void 0:l.kernel)&&void 0!==s?s:null;await g(c),await v(c);const d=t.activeCell;if(d){const e=(e=>{let t=null;return()=>{t&&window.clearTimeout(t),t=window.setTimeout(e,2e3)}})(()=>v(c));d.model.sharedModel.changed.connect(()=>{e()}),console.log("MCP Active Cell Bridge: Tracking new active cell")}}),t.currentChanged.connect(async(e,n)=>{var o,l,s;const c=null!==(s=null===(l=null===(o=t.currentWidget)||void 0===o?void 0:o.sessionContext.session)||void 0===l?void 0:l.kernel)&&void 0!==s?s:null;await g(c),await v(c),console.log("MCP Active Cell Bridge: Notebook changed, sent snapshot")}),t.widgetAdded.connect((e,t)=>{t.sessionContext.ready.then(()=>{var e,n;const o=null!==(n=null===(e=t.sessionContext.session)||void 0===e?void 0:e.kernel)&&void 0!==n?n:null;g(o),o&&p(o),console.log("MCP Active Cell Bridge: Kernel ready, setting up comms")})}),t.forEach(e=>{var t,n;const o=null!==(n=null===(t=e.sessionContext.session)||void 0===t?void 0:t.kernel)&&void 0!==n?n:null;o&&p(o)}),console.log("MCP Active Cell Bridge: Event listeners registered")}}}}]);