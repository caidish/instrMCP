"use strict";(self.webpackChunkmcp_active_cell_bridge=self.webpackChunkmcp_active_cell_bridge||[]).push([[509],{509:(e,t,s)=>{s.r(t),s.d(t,{default:()=>o});var l=s(980);const o={id:"mcp-active-cell-bridge:plugin",description:"Bridge active cell content to MCP server via kernel comm",autoStart:!0,requires:[l.INotebookTracker],activate:(e,t)=>{console.log("MCP Active Cell Bridge extension activated");const s=new WeakMap,o=new WeakMap,n=new WeakMap,c=(e,t)=>t&&!t.isDisposed&&!0===o.get(e),d=async e=>{if(!e||!e.status||"dead"===e.status)return console.warn("MCP Active Cell Bridge: Kernel not available or dead"),null;if("idle"!==e.status&&"busy"!==e.status)return console.warn(`MCP Active Cell Bridge: Kernel not ready (status: ${e.status})`),null;let d=s.get(e);if(!d||!c(e,d)){let c=n.get(e);if(c)try{return await c,s.get(e)||null}catch(e){return null}return c=(async()=>{try{return d=e.createComm("mcp:active_cell"),d.onMsg=s=>{var o;const n=(null===(o=null==s?void 0:s.content)||void 0===o?void 0:o.data)||{},c=n.type;"request_current"===c?r(e):"update_cell"===c?(async(e,s,l)=>{const o=l.request_id,n=l.content;try{const e=t.currentWidget,l=t.activeCell;if(!e||!l)return void s.send({type:"update_response",request_id:o,success:!1,message:"No active cell available for update"});l.model.sharedModel.setSource(n),s.send({type:"update_response",request_id:o,success:!0,cell_id:l.model.id,message:"Cell updated successfully"}),console.log(`MCP Active Cell Bridge: Updated cell content (${n.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to update cell:",e),s.send({type:"update_response",request_id:o,success:!1,message:`Failed to update cell: ${e}`})}})(0,d,n):"execute_cell"===c?(async(e,s,o)=>{const n=o.request_id;try{const e=t.currentWidget,o=t.activeCell;if(!e||!o)return void s.send({type:"execute_response",request_id:n,success:!1,message:"No active cell available for execution"});await l.NotebookActions.run(e.content,e.sessionContext),s.send({type:"execute_response",request_id:n,success:!0,cell_id:o.model.id,message:"Cell executed successfully"}),console.log("MCP Active Cell Bridge: Executed active cell")}catch(e){console.error("MCP Active Cell Bridge: Failed to execute cell:",e),s.send({type:"execute_response",request_id:n,success:!1,message:`Failed to execute cell: ${e}`})}})(0,d,n):"add_cell"===c?(async(e,s,o)=>{const n=o.request_id,c=o.cell_type||"code",d=o.position||"below",r=o.content||"";try{const e=t.currentWidget;if(!e)return void s.send({type:"add_cell_response",request_id:n,success:!1,message:"No active notebook available"});const o=["code","markdown","raw"];if(!o.includes(c))return void s.send({type:"add_cell_response",request_id:n,success:!1,message:`Invalid cell_type '${c}'. Must be one of: ${o.join(", ")}`});const i=["above","below"];if(!i.includes(d))return void s.send({type:"add_cell_response",request_id:n,success:!1,message:`Invalid position '${d}'. Must be one of: ${i.join(", ")}`});"above"===d?await l.NotebookActions.insertAbove(e.content):await l.NotebookActions.insertBelow(e.content);const a=t.activeCell;a&&(a.model.type!==c&&await l.NotebookActions.changeCellType(e.content,c),r&&a.model.sharedModel.setSource(r)),s.send({type:"add_cell_response",request_id:n,success:!0,cell_type:c,position:d,content_length:r.length,cell_id:null==a?void 0:a.model.id,message:"Cell added successfully"}),console.log(`MCP Active Cell Bridge: Added ${c} cell ${d} with ${r.length} chars`)}catch(e){console.error("MCP Active Cell Bridge: Failed to add cell:",e),s.send({type:"add_cell_response",request_id:n,success:!1,message:`Failed to add cell: ${e}`})}})(0,d,n):"delete_cell"===c?(async(e,s,o)=>{var n;const c=o.request_id;try{const e=t.currentWidget,o=t.activeCell;if(!e||!o)return void s.send({type:"delete_cell_response",request_id:c,success:!1,message:"No active cell available for deletion"});const d=o.model.id;((null===(n=e.content.model)||void 0===n?void 0:n.cells.length)||0)<=1?(o.model.sharedModel.setSource(""),s.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:d,action:"cleared",message:"Last cell content cleared (cell preserved)"}),console.log("MCP Active Cell Bridge: Cleared last cell content")):(await l.NotebookActions.deleteCells(e.content),s.send({type:"delete_cell_response",request_id:c,success:!0,cell_id:d,action:"deleted",message:"Cell deleted successfully"}),console.log("MCP Active Cell Bridge: Deleted cell"))}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cell:",e),s.send({type:"delete_cell_response",request_id:c,success:!1,message:`Failed to delete cell: ${e}`})}})(0,d,n):"delete_cells_by_number"===c?(async(e,s,l)=>{var o,n;const c=l.request_id,d=l.cell_numbers||[];try{const e=t.currentWidget;if(!e)return void s.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"No active notebook available"});if(!Array.isArray(d)||0===d.length)return void s.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"cell_numbers must be a non-empty array"});const l=e.content,r=null===(o=l.model)||void 0===o?void 0:o.cells;if(!r)return void s.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:"Cannot access notebook cells"});const i=new Map;for(let e=0;e<r.length;e++){const t=r.get(e).executionCount;null!=t&&i.set(t,e)}const a=[],u=[];for(const e of d)if(i.has(e)){const t=i.get(e);u.push(t),a.push({cell_number:e,index:t,success:!0})}else a.push({cell_number:e,success:!1,message:`Cell with execution count ${e} not found`});u.sort((e,t)=>t-e);let _=0,g=0;for(const e of u)try{if(1===r.length){const t=r.get(e);if(t){t.sharedModel.setSource("");const s=a.findIndex(t=>t.index===e);-1!==s&&(a[s].message="Last cell - content cleared instead of deleted",a[s].cleared=!0),g++}}else null===(n=l.model)||void 0===n||n.sharedModel.deleteCell(e),_++}catch(t){const s=a.findIndex(t=>t.index===e);-1!==s&&(a[s].success=!1,a[s].message=`Failed to delete: ${t}`)}s.send({type:"delete_cells_by_number_response",request_id:c,success:!0,deleted_count:_,total_requested:d.length,results:a,message:`Deleted ${_} cell(s)`}),console.log(`MCP Active Cell Bridge: Deleted ${_} cells by number`)}catch(e){console.error("MCP Active Cell Bridge: Failed to delete cells by number:",e),s.send({type:"delete_cells_by_number_response",request_id:c,success:!1,message:`Failed to delete cells: ${e}`})}})(0,d,n):"move_cursor"===c?(async(e,s,l)=>{var o;const n=l.request_id,c=l.target;try{const e=t.currentWidget,l=null==e?void 0:e.content;if(!e||!l)return void s.send({type:"move_cursor_response",request_id:n,success:!1,message:"No active notebook available"});const d=null===(o=l.model)||void 0===o?void 0:o.cells;if(!d||0===d.length)return void s.send({type:"move_cursor_response",request_id:n,success:!1,message:"No cells in notebook"});const r=l.activeCellIndex;let i;if("above"===c)i=r-1;else if("below"===c)i=r+1;else{const e=parseInt(c);if(isNaN(e))return void s.send({type:"move_cursor_response",request_id:n,success:!1,message:`Invalid target '${c}'. Must be 'above', 'below', or a cell number`});let t=!1;for(let s=0;s<d.length;s++)if(d.get(s).executionCount===e){i=s,t=!0;break}if(!t)return void s.send({type:"move_cursor_response",request_id:n,success:!1,message:`Cell with execution count ${e} not found`})}i=Math.max(0,Math.min(i,d.length-1)),l.activeCellIndex=i;const a=l.activeCell;a&&l.scrollToCell(a),s.send({type:"move_cursor_response",request_id:n,success:!0,old_index:r,new_index:i,message:`Cursor moved from index ${r} to ${i}`}),console.log(`MCP Active Cell Bridge: Moved cursor from ${r} to ${i}`)}catch(e){console.error("MCP Active Cell Bridge: Failed to move cursor:",e),s.send({type:"move_cursor_response",request_id:n,success:!1,message:`Failed to move cursor: ${e}`})}})(0,d,n):"apply_patch"===c?(async(e,s,l)=>{const o=l.request_id,n=l.old_text||"",c=l.new_text||"";try{const e=t.currentWidget,l=t.activeCell;if(!e||!l)return void s.send({type:"apply_patch_response",request_id:o,success:!1,message:"No active cell available for patching"});if(!n)return void s.send({type:"apply_patch_response",request_id:o,success:!1,message:"old_text parameter cannot be empty"});const d=l.model.sharedModel.getSource(),r=d.replace(n,c);r!==d?(l.model.sharedModel.setSource(r),s.send({type:"apply_patch_response",request_id:o,success:!0,cell_id:l.model.id,replaced:!0,old_text_length:n.length,new_text_length:c.length,content_length_before:d.length,content_length_after:r.length,message:"Patch applied successfully"}),console.log(`MCP Active Cell Bridge: Applied patch (${n.length} -> ${c.length} chars)`)):(s.send({type:"apply_patch_response",request_id:o,success:!0,cell_id:l.model.id,replaced:!1,old_text_length:n.length,new_text_length:c.length,message:"Patch target not found - no changes made"}),console.log("MCP Active Cell Bridge: Patch target not found"))}catch(e){console.error("MCP Active Cell Bridge: Failed to apply patch:",e),s.send({type:"apply_patch_response",request_id:o,success:!1,message:`Failed to apply patch: ${e}`})}})(0,d,n):console.warn(`MCP Active Cell Bridge: Unknown message type: ${c}`)},d.onClose=t=>{console.log("MCP Active Cell Bridge: Comm closed"),o.delete(e),s.delete(e),n.delete(e)},await d.open({}).done,o.set(e,!0),s.set(e,d),d}catch(t){console.error("MCP Active Cell Bridge: Failed to create comm:",t);const l=(null==t?void 0:t.toString())||"";throw(l.includes("No such comm target")||l.includes("comm target"))&&(console.error("MCP Active Cell Bridge: Kernel comm target not registered!"),console.error("Run this command in a notebook cell: %load_ext servers.jupyter_qcodes.jupyter_mcp_extension")),o.delete(e),s.delete(e),t}finally{n.delete(e)}})(),n.set(e,c),await c}return d},r=async l=>{var r,i,a,u,_,g,v;const p=t.currentWidget,m=t.activeCell;if(!p||!m)return;const C=null!=l?l:null===(r=p.sessionContext.session)||void 0===r?void 0:r.kernel;if(!C)return;const y=await d(C);if(y&&c(C,y))try{const t=m.editor,s=m.model.sharedModel.getSource();let l=null;try{l=null!==(a=null===(i=null==t?void 0:t.getCursorPosition)||void 0===i?void 0:i.call(t))&&void 0!==a?a:null}catch(e){}let o=null;try{const e=null!==(_=null===(u=null==t?void 0:t.getSelection)||void 0===u?void 0:u.call(t))&&void 0!==_?_:null;e&&e.start!==e.end&&(o={start:e.start,end:e.end})}catch(e){}const n=5e4;let c=s,d=!1;s.length>n&&(c=s.slice(0,n),d=!0);const r={type:"snapshot",path:p.context.path,index:p.content.activeCellIndex,id:m.model.id,cell_type:m.model.type,text:c,cursor:l,selection:o,truncated:d,original_length:s.length,ts_ms:Date.now(),client_id:null!==(v=null===(g=e.info)||void 0===g?void 0:g.workspace)&&void 0!==v?v:"unknown"};y.send(r),console.log(`MCP Active Cell Bridge: Sent snapshot (${c.length} chars)`)}catch(e){console.error("MCP Active Cell Bridge: Failed to send snapshot:",e),s.delete(C),o.delete(C),n.delete(C)}else console.warn("MCP Active Cell Bridge: Comm not ready for sending")};t.activeCellChanged.connect(async(e,s)=>{var l,o,n;const c=null!==(n=null===(o=null===(l=t.currentWidget)||void 0===l?void 0:l.sessionContext.session)||void 0===o?void 0:o.kernel)&&void 0!==n?n:null;await d(c),await r(c);const i=t.activeCell;if(i){const e=(e=>{let t=null;return()=>{t&&window.clearTimeout(t),t=window.setTimeout(e,2e3)}})(()=>r(c));i.model.sharedModel.changed.connect(()=>{e()}),console.log("MCP Active Cell Bridge: Tracking new active cell")}}),t.currentChanged.connect(async(e,s)=>{var l,o,n;const c=null!==(n=null===(o=null===(l=t.currentWidget)||void 0===l?void 0:l.sessionContext.session)||void 0===o?void 0:o.kernel)&&void 0!==n?n:null;await d(c),await r(c),console.log("MCP Active Cell Bridge: Notebook changed, sent snapshot")}),t.widgetAdded.connect((e,t)=>{t.sessionContext.ready.then(()=>{var e,s;const l=null!==(s=null===(e=t.sessionContext.session)||void 0===e?void 0:e.kernel)&&void 0!==s?s:null;d(l),console.log("MCP Active Cell Bridge: Kernel ready, setting up comm")})}),console.log("MCP Active Cell Bridge: Event listeners registered")}}}}]);